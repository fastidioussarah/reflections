What happens when you initialize a repository? Why do you need to do it?

Initializing a repository generates the metadata that Git uses in order
to track revisions made to it. If you don't initialize a repository, then
you cannot commit your changes, and Git cannot track revisions. 

How is the staging area different from the working directory and the repository?
What value do you think it offers?

The staging area allows one to essentially format their commits, so they can
make logical sense. If one was only allowed to commit one file at a time, it
might split up commits that represent one logical change, if that logical change
took place throughout more than one file. The staging area allows one to pick
and choose exactly which files represent a logical change, and group them all
together in one commit.

How can you use the staging area to make sure you have one commit per logical
change?

Because you can add multiple files to the staging area and put them all in one
commit, your commits can all be of one logical change, even if this logical change
spans files.

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

Branches allow you to have more than one feature set. If you want your end
product two have two or more variants, then branching is one way to accomplish
that. Branching can also be used in trying out an experimental feature. If
you use a branch to add an experimental feature, you can always go back to a
working version of the code, which is when the branch split off from the master.

How do the diagrams help you visualize the branch structure?

Understanding which commits belong to which branches and visualizing that
helps you avoid creating unreachable commits.

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Git's automatic merging vs. always doing merges
manually?
